// MainActivity.kt
// Не забудьте добавить зависимости в ваш build.gradle.kts (app)
// implementation("androidx.core:core-ktx:1.12.0")
// implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.6.2")
// implementation("androidx.activity:activity-compose:1.8.2")
// implementation(platform("androidx.compose:compose-bom:2023.08.00"))
// implementation("androidx.compose.ui:ui")
// implementation("androidx.compose.ui:ui-graphics")
// implementation("androidx.compose.ui:ui-tooling-preview")
// implementation("androidx.compose.material3:material3")
//
// // CameraX
// implementation("androidx.camera:camera-core:1.3.1")
// implementation("androidx.camera:camera-camera2:1.3.1")
// implementation("androidx.camera:camera-lifecycle:1.3.1")
// implementation("androidx.camera:camera-view:1.3.1")
//
// // ML Kit Text Recognition
// implementation("com.google.android.gms:play-services-mlkit-text-recognition:19.0.0")
//
// // ViewModel
// implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.6.2")
//
// Также необходимо запросить разрешения в AndroidManifest.xml:
// <uses-feature android:name="android.hardware.camera.any" />
// <uses-permission android:name="android.permission.CAMERA" />


import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.latin.TextRecognizerOptions
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.io.File
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.Executor
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

// --- Модель данных ---
data class ParsedItem(
    val id: UUID = UUID.randomUUID(), // для уникальности в списках
    var name: String,
    var price: Double?,
    var category: String
)

// --- Состояние UI ---
data class UiState(
    val status: String = "Готов к сканированию",
    val isBusy: Boolean = false,
    val items: List<ParsedItem> = emptyList(),
    val total: Double = 0.0,
    val hasCameraPermission: Boolean = false
)

// --- ViewModel для управления логикой и состоянием ---
class ReceiptScannerViewModel : ViewModel() {

    private val _uiState = MutableStateFlow(UiState())
    val uiState: StateFlow<UiState> = _uiState.asStateFlow()

    private val keywordCategories = mapOf(
        "молоко" to "Молочные продукты",
        "кефир" to "Молочные продукты",
        "хлеб" to "Выпечка",
        "булка" to "Выпечка",
        "сахар" to "Продукты",
        "мука" to "Продукты",
        "яйц" to "Продукты",
        "яблок" to "Фрукты",
        "банан" to "Фрукты",
        "чай" to "Напитки",
        "кофе" to "Напитки",
        "салфет" to "Бытовая химия",
        "порошок" to "Бытовая химия",
        "пельмен" to "Полуфабрикаты"
    )

    fun onPermissionResult(isGranted: Boolean) {
        _uiState.update { it.copy(hasCameraPermission = isGranted, status = if(isGranted) "Разрешение получено" else "Нет разрешения на использование камеры") }
    }

    fun processImage(context: Context, uri: Uri) {
        viewModelScope.launch {
            _uiState.update { it.copy(isBusy = true, status = "Обработка...", items = emptyList()) }
            try {
                val inputImage = InputImage.fromFilePath(context, uri)
                val recognizer = TextRecognition.getClient(TextRecognizerOptions.DEFAULT_OPTIONS)

                recognizer.process(inputImage)
                    .addOnSuccessListener { visionText ->
                        val lines = visionText.textBlocks.flatMap { block -> block.lines.map { line -> line.text } }
                        val parsed = parseReceiptLines(lines)
                        val classified = parsed.map { p ->
                            p.copy(category = classifyByKeywords(p.name))
                        }
                        _uiState.update {
                            it.copy(
                                items = classified,
                                status = "Готово. Найдено ${classified.size} позиций",
                                total = classified.sumOf { item -> item.price ?: 0.0 },
                                isBusy = false
                            )
                        }
                    }
                    .addOnFailureListener { e ->
                        _uiState.update { it.copy(status = "Ошибка: ${e.message}", isBusy = false) }
                    }

            } catch (e: Exception) {
                _uiState.update { it.copy(status = "Ошибка: ${e.message}", isBusy = false) }
            }
        }
    }

    private fun parseReceiptLines(lines: List<String>): List<ParsedItem> {
        val res = mutableListOf<ParsedItem>()
        val priceReg = """(\d+[.,]?\d{0,2})\s*$""".toRegex()
        for (raw in lines) {
            var s = raw.trim().lowercase(Locale.getDefault())
            s = s.replace("""[^а-яА-Яa-zA-Z0-9,.\s-]""".toRegex(), " ").trim()
            val m = priceReg.find(s)
            if (m != null) {
                val priceStr = m.groupValues[1].replace(',', '.')
                val price = priceStr.toDoubleOrNull()
                if (price != null) {
                    val name = s.substring(0, m.range.first).trim()
                    if (name.isNotEmpty()) {
                        res.add(ParsedItem(name = capitalize(name), price = price, category = "Неизвестно"))
                    }
                }
            }
        }
        if (res.isEmpty()) {
            for (s in lines) {
                val cleaned = s.trim()
                if (cleaned.length > 4) {
                    res.add(ParsedItem(name = capitalize(cleaned), price = 0.0, category = "Неизвестно"))
                }
            }
        }
        return res
    }

    private fun classifyByKeywords(name: String): String {
        val low = name.lowercase(Locale.getDefault())
        for ((key, value) in keywordCategories) {
            if (low.contains(key)) return value
        }
        return "Другое"
    }
    
    fun updateItem(itemToUpdate: ParsedItem, newPrice: String, newCategory: String) {
        val price = newPrice.replace(',', '.').toDoubleOrNull() ?: itemToUpdate.price
        val updatedItems = _uiState.value.items.map {
            if (it.id == itemToUpdate.id) {
                it.copy(price = price, category = newCategory)
            } else {
                it
            }
        }
        _uiState.update {
            it.copy(
                items = updatedItems,
                total = updatedItems.sumOf { item -> item.price ?: 0.0 }
            )
        }
    }

    private fun capitalize(s: String): String {
        return s.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }
    }
}

// --- Главная Activity ---
class MainActivity : ComponentActivity() {

    private val viewModel = ReceiptScannerViewModel()

    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean ->
        viewModel.onPermissionResult(isGranted)
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        requestCameraPermission()
        setContent {
            MaterialTheme {
                ReceiptScannerApp(viewModel)
            }
        }
    }
    private fun requestCameraPermission() {
        when {
            ContextCompat.checkSelfPermission(
                this,
                Manifest.permission.CAMERA
            ) == PackageManager.PERMISSION_GRANTED -> {
                viewModel.onPermissionResult(true)
            }
            else -> {
                requestPermissionLauncher.launch(Manifest.permission.CAMERA)
            }
        }
    }
}


// --- UI (Jetpack Compose) ---
@Composable
fun ReceiptScannerApp(viewModel: ReceiptScannerViewModel) {
    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current
    val imageCapture = remember { ImageCapture.Builder().build() }
    var showEditDialog by remember { mutableStateOf<ParsedItem?>(null) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Трекер расходов") },
                colors = TopAppBarDefaults.topAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primary,
                    titleContentColor = MaterialTheme.colorScheme.onPrimary
                )
            )
        }
    ) { padding ->
        Column(modifier = Modifier.fillMaxSize().padding(padding)) {
            Box(
                modifier = Modifier.fillMaxWidth().weight(4f).background(Color.Black),
                contentAlignment = Alignment.Center
            ) {
                if (uiState.hasCameraPermission) {
                    CameraPreview(
                        modifier = Modifier.fillMaxSize(),
                        imageCapture = imageCapture
                    )
                } else {
                    Text("Требуется разрешение на использование камеры", color = Color.White)
                }
            }

            Column(
                modifier = Modifier.fillMaxWidth().weight(5f).padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text("Статус: ${uiState.status}")
                Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                    Button(
                        onClick = {
                            takePhoto(context, imageCapture) { uri ->
                                viewModel.processImage(context, uri)
                            }
                        },
                        enabled = !uiState.isBusy && uiState.hasCameraPermission
                    ) {
                        Text("Сканировать чек")
                    }
                    Button(
                        onClick = { /* Логика добавления в покупки */ },
                        enabled = uiState.items.isNotEmpty()
                    ) {
                        Text("Добавить")
                    }
                }
                Text("Распознанные позиции:", fontWeight = FontWeight.Bold)

                if (uiState.items.isEmpty()) {
                    Box(modifier = Modifier.weight(1f), contentAlignment = Alignment.Center) {
                        Text("Пока нет распознанных позиций")
                    }
                } else {
                    LazyColumn(modifier = Modifier.weight(1f)) {
                        items(uiState.items, key = { it.id }) { item ->
                            ListItem(
                                headlineContent = { Text(item.name) },
                                supportingContent = { Text(item.category) },
                                trailingContent = { Text(String.format("%.2f", item.price ?: 0.0)) },
                                modifier = Modifier.clickable { showEditDialog = item }
                            )
                            Divider()
                        }
                    }
                }
                Text("Итого: ${String.format("%.2f", uiState.total)}", fontWeight = FontWeight.Bold)
            }
        }
    }
    
    showEditDialog?.let { item ->
        EditItemDialog(
            item = item,
            onDismiss = { showEditDialog = null },
            onSave = { price, category ->
                viewModel.updateItem(item, price, category)
                showEditDialog = null
            }
        )
    }
}

@Composable
fun CameraPreview(
    modifier: Modifier = Modifier,
    cameraSelector: CameraSelector = CameraSelector.DEFAULT_BACK_CAMERA,
    imageCapture: ImageCapture
) {
    val lifecycleOwner = LocalLifecycleOwner.current
    val context = LocalContext.current
    AndroidView(
        modifier = modifier,
        factory = {
            PreviewView(it).apply {
                this.scaleType = PreviewView.ScaleType.FILL_CENTER
                val cameraProviderFuture = ProcessCameraProvider.getInstance(it)
                cameraProviderFuture.addListener({
                    val cameraProvider = cameraProviderFuture.get()
                    val preview = Preview.Builder().build().also {
                        it.setSurfaceProvider(this.surfaceProvider)
                    }
                    try {
                        cameraProvider.unbindAll()
                        cameraProvider.bindToLifecycle(
                            lifecycleOwner,
                            cameraSelector,
                            preview,
                            imageCapture
                        )
                    } catch (e: Exception) {
                        Log.e("CameraPreview", "Ошибка привязки: ", e)
                    }
                }, ContextCompat.getMainExecutor(it))
            }
        }
    )
}

fun takePhoto(
    context: Context,
    imageCapture: ImageCapture,
    onImageCaptured: (Uri) -> Unit
) {
    val file = File(
        context.externalCacheDir,
        "receipt_${System.currentTimeMillis()}.jpg"
    )
    val outputOptions = ImageCapture.OutputFileOptions.Builder(file).build()

    imageCapture.takePicture(
        outputOptions,
        ContextCompat.getMainExecutor(context),
        object : ImageCapture.OnImageSavedCallback {
            override fun onImageSaved(outputFileResults: ImageCapture.OutputFileResults) {
                outputFileResults.savedUri?.let { onImageCaptured(it) }
            }

            override fun onError(exception: ImageCaptureException) {
                Log.e("TakePhoto", "Ошибка съемки: ", exception)
            }
        }
    )
}

@Composable
fun EditItemDialog(
    item: ParsedItem,
    onDismiss: () -> Unit,
    onSave: (String, String) -> Unit
) {
    var price by remember { mutableStateOf(item.price?.toString() ?: "") }
    var category by remember { mutableStateOf(item.category) }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Правка: ${item.name}") },
        text = {
            Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                OutlinedTextField(
                    value = price,
                    onValueChange = { price = it },
                    label = { Text("Цена") }
                )
                OutlinedTextField(
                    value = category,
                    onValueChange = { category = it },
                    label = { Text("Категория") }
                )
            }
        },
        confirmButton = {
            Button(onClick = { onSave(price, category) }) {
                Text("Сохранить")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Отмена")
            }
        }
    )
}
